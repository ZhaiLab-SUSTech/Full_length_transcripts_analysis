#!/usr/bin/env python3
# -*- coding: utf-8 -*-
'''
@Author       : windz
@Date         : 2020-04-14 10:46:37
LastEditTime : 2020-10-31 16:08:35
@Description  : Extract polyA position from PacBio ccs seqeunce without adapters and has the same strand with mRNA.
'''


import pysam
import click

import logging
logging.basicConfig(level=logging.DEBUG,  
                    format='%(asctime)s %(filename)s: %(message)s',  
                    datefmt='%m/%d/%Y %I:%M:%S %p',
                    )


def max_subarray(A):
    """
    Maximum subarray problem: select subarray with maxmium sum
    modified Kadane's algorithm (not greedy)
    
    return (index is 0-based), you can get the subarray by A[start_index:(end_index+1)]:
    [start_index, end_index, sum]
    
    if the maxmium sum is <= 0, then return [-1, -1, 0]
    """
        
    max_ending_here = max_so_far = 0
    max_start_index = startIndex = 0
    max_end_index = -1
    for i, x in enumerate(A):
        if 0 >= max_ending_here + x:
        #For greedy at left side : if 0 > max_ending_here + x:
            startIndex = i+1
            max_ending_here = 0
        else:
            max_ending_here += x
        if max_ending_here > max_so_far:
        #For greedy at right side : if max_ending_here >= max_so_far:
            max_so_far = max_ending_here
            max_start_index = startIndex
            max_end_index = i
    
    if max_so_far <= 0 or (max_start_index > max_end_index):
        return -1, -1, 0
    else:
        return max_start_index, max_end_index, max_so_far


def polyA_finder(seq, base="A", match = 1, mis = -1.5):

    scores = [match if base == s else mis for s in seq]
    start_index, end_index, max_score = max_subarray(scores)

    return start_index, end_index+1, max_score, seq[start_index:(end_index+1)]


# reverse complement
old_chars = "ACGT"
replace_chars = "TGCA"
tab = str.maketrans(old_chars,replace_chars)
def reverse_complement(seq):
    return seq.translate(tab)[::-1]


@click.command()
@click.option('--infile', help='Input bam file generated by minimap2',required=True, type=click.Path(exists=True))
@click.option('--out', help='Out poly results. Remove chimerical reads.', required=True)
@click.option('--fasta', help='Out polya seuqnces.', required=True)
def main(infile, out, fasta):
    o_tsv = open(out, 'w')
    o_fasta = open(fasta, 'w')

    o_tsv.write('read_id\tpolya_start_base\tpolya_end_base\tpolya_length\n')
    with pysam.AlignmentFile(infile, 'rb') as inbam:
        for read in inbam:
            # 过滤比对不上和能比对到多处的reads
            if read.is_unmapped:
                continue

            seq = read.query_sequence
            if read.is_reverse:
                seq = reverse_complement(seq)
                polya_start_base = read.query_length-read.query_alignment_start
            else:
                polya_start_base = read.query_alignment_end
            

            clip_seq = seq[polya_start_base: ]
            clip_seq_len = len(clip_seq)
            a_count = clip_seq.count('A')
            if clip_seq_len < 15 or clip_seq_len-a_count > 20 or (clip_seq_len-a_count)/clip_seq_len >= .5:
                o_tsv.write(f'{read.query_name}\t{-1}\t{-1}\t{-1}\n')
                continue

            polya_start, polya_end, max_score, polya_seq = polyA_finder(clip_seq)

            polya_start_base += polya_start
            polya_end_base = polya_start_base+polya_end

            if read.query_length-polya_end_base <=5:
                polya_end_base = read.query_length
                
            polya_seq = seq[polya_start_base: polya_end_base]
            polya_len = polya_end_base-polya_start_base

            o_tsv.write(f'{read.query_name}\t{polya_start_base}\t{polya_end_base}\t{polya_len}\n')
            o_fasta.write(f'>{read.query_name}\n{polya_seq}\n')
    
    o_tsv.close()
    o_fasta.close()
            
if __name__ == "__main__":
    main()